;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                                                           ;;
;;        Program that performs ROT-N encryption                             ;;
;;                                                                           ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


extern fopen
extern fclose
extern fread
extern memset
extern atoi
extern strlen
extern printf

%define BUF_SIZE 26
%define ELEMENT_SIZE 1

section .data:
  i      : dd 0
  j      : dd 0

section .rodata:
  open_mode : db "r", 0
  output    : db "%s", 0
  error     : db "Cannot open file", 10, 0

section .bss:
  buffer    : resb BUF_SIZE + 1
  copy      : resb BUF_SIZE + 1
  ans       : resb BUF_SIZE + 1
  filename  : resd 1
  fh        : resd 1
  j         : resd 1
  length    : resd 1

section .text:
  global main

  main:
    push ebp
    mov ebp, esp

    mov esi, DWORD[esp + 12]

    mov eax, [esi + 4]
    mov DWORD[filename], eax
    push open_mode
    push DWORD[filename]
    call fopen
    add esp, 8
    test eax, eax
    jz .openfailed

    mov [fh], eax

    push BUF_SIZE
    push 0
    push buffer
    call memset
    add esp, 12

    push BUF_SIZE
    push 0
    push copy
    call memset
    add esp, 12

    push BUF_SIZE
    push 0
    push copy
    call memset
    add esp, 12

    push DWORD[fh]
    push BUF_SIZE
    push ELEMENT_SIZE
    push buffer
    call fread
    add esp, 16
    mov BYTE [buffer + BUF_SIZE], 0

    add esi, 4
    mov eax, DWORD[esi]
    push eax
    call atoi
    add esp, 4
    mov DWORD[j], eax

    .loop:
      cmp DWORD[j], 26
      jg .mod

    .l1:
      cmp DWORD[j], 0
      je .print
      ans[i] = copy[j]
      inc DWORD[i]
      inc DWORD[j]
      mov eax, DWORD[i]
      cmp eax, DWORD[j]
      jge .jump
      cmp DWORD[j], 26
      jge .jump
      jmp .l1

    .jump:
      mov ans[i], 0
      push ans
      call strlen
      mov DWORD[length], eax

      mov DWORD[i], eax
      mov DWORD[j], 0
      mov eax, buffer[j]
      mov ans[i], eax
      inc DWORD[i]
      inc DWORD[j]
      cmp DWORD[i], 

    .mod:
      mov edx, 0
      mov eax, DWORD[j]
      mov ecx, 26
      div ecx
      mov DWORD[j], edx
      jmp .l1

    .print:
      push buffer
      push output
      call printf
      add esp, 8

      push DWORD[fh]
      call fclose
      add esp, 4
      mov eax, 0
      jmp .final

  .openfailed:
    push error
    call printf
    add esp, 4
    mov eax, 1

  .final:
    leave
    ret
