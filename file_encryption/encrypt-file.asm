;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                                                           ;;
;;        Program that performs ROT-N encryption                             ;;
;;                                                                           ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

extern fclose
extern fopen
extern fread
extern memset
extern atoi
extern strlen
extern printf

%define BUF_SIZE 20
%define ELEM_SIZE 1

section .data
    i        : dd 0


section .rodata
    error         : db "Cannot open file! Exiting!", 10, 0
    open_mode     : db "r", 0
    output        : db "%s", 0

section .bss
    buffer   : resb BUF_SIZE + 1
    answer   : resb BUF_SIZE + 1
    filename : resd 1
    fh       : resd 1
    j        : resd 1
    j_copy   : resd 1
    length   : resd 1

section .text
    global main

    main:
        push ebp
        mov ebp, esp

        mov edi, DWORD [esp + 8]
        mov esi, DWORD [esp + 12]
        mov eax, [esi + 4]
        mov DWORD[filename], eax
        push open_mode
        push DWORD[filename]
        call fopen
        add esp, 8
        test eax, eax
        jz .openfailed

        mov [fh], eax

        push BUF_SIZE
        push 0
        push buffer
        call memset
        add esp, 12

        push BUF_SIZE
        push 0
        push ans
        call memset
        add esp, 12

        push DWORD[fh]
        push BUF_SIZE
        push ELEM_SIZE
        push buffer
        call fread
        add esp, 16
        mov BYTE [buffer + BUF_SIZE], 0

        add esi, 4
        mov eax, DWORD[esi]
        push eax
        call atoi
        add esp, 4
        mov DWORD[j_copy], eax
        mov DWORD[j], eax

        cmp DWORD[j], 26
        jg .mod

      .l1:
        cmp DWORD[j], 0
        je .print
        jl .neg
        mov eax, BYTE[buffer + j]
        mov BYTE [answer + i], eax                       ;answer[i] = buffer[j]
        inc DWORD[i]
        inc DWORD[j]
        mov eax, DWORD[i]
        cmp eax, DWORD[j]
        jl .l1
        cmp DWORD[j], 26
        jl .l1

        mov BYTE [answer + i], 0
        push answer
        call strlen
        add esp, 4

        mov DWORD[length], eax
        mov DWORD[i], eax
        mov DWORD[j], 0

      .loop:
        cmp DWORD[i], 26
        jge .l2
        mov eax, DWORD[j]
        cmp eax, DWORD[j_copy]
        jge .l2
        mov eax, BYTE [buffer + j]
        mov BYTE [answer + i], eax                        ;answer[i] = buffer[j]
        inc DWORD[i]
        inc DWORD[j]
        jmp .loop

      .l2:
        mov BYTE [answer + i], 0
        push answer
        push output
        call printf
        add esp, 8
        jmp .fclose


      .mod:
        mov edx, 0
        mov eax, DWORD[j]
        mov ecx, 26
        div ecx
        mov DWORD[j], edx
        jmp .l1

      .neg:
        mov edx, 0
        mov eax, DWORD[j]
        mov ecx, -26
        div ecx
        mov DWORD[j], edx

        mov DWORD[i], 0
        mov eax, DWORD[j_copy]
        add eax, 26
        mov DWORD[j], eax

      .loop2:
        mov eax, BYTE[buffer + j]
        mov BYTE[answer + i], eax
        inc DWORD[i]
        inc DWORD[j]
        mov eax, DWORD[j_copy]
        imul eax, -1
        jge .l3
        cmp DWORD[j], 26
        jge .l3
        jmp .loop2

      .l3:
        mov BYTE[answer + i], 0
        push answer
        push output
        call printf
        add esp, 8
        jmp .fclose

      .print:
        push buffer
        push output
        call printf
        add esp, 8

      .fclose:
        push DWORD[fh]
        call fclose
        add esp, 4
        mov eax, 0
        jmp .final

      .openfailed:
        push error
        call printf
        add esp, 4
        mov eax, 1

      .final:
        leave
        ret
